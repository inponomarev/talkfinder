<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>

  <meta name="description" content="JUG Talks Finder">
  <meta name="author" content="Ivan Ponomarev">
  <link rel="stylesheet" href="/css/foundation.css">
  <link rel="stylesheet" href="/css/font-awesome.css">
  <link rel="stylesheet" href="/css/coderay.css">
  <link rel="stylesheet" href="/css/asciidoctor.css">
  <link rel="stylesheet" href="/css/custom.css">
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
    (function (m, e, t, r, i, k, a) {
      m[i] = m[i] || function () { (m[i].a = m[i].a || []).push(arguments) };
      m[i].l = 1 * new Date(); k = e.createElement(t), a = e.getElementsByTagName(t)[0], k.async = 1, k.src = r, a.parentNode.insertBefore(k, a)
    })
      (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(64729483, "init", {
      clickmap: true,
      trackLinks: true,
      accurateTrackBounce: true
    });
  </script>
  <noscript>
    <div><img src="https://mc.yandex.ru/watch/64729483" style="position:absolute; left:-9999px;" alt="" /></div>
  </noscript>
  <!-- /Yandex.Metrika counter -->
  <script src="/js/vendor/modernizr.js"></script>
  <script src="/js/toc.js"></script>
  <script src="/js/simple-jekyll-search.min.js"></script>
</head>
<body>
  <nav class="top-bar">
    <ul class="title-area">
      <li class="name">
        <h1>
          <a href="/ru/events.html">События</a>
          <a href="/ru/speakers.html">Спикеры</a>
          <a href="/ru/search.html">Поиск</a>
          <a href="/ru/about.html">О проекте</a>
          <a class="lang" href="/en/talk/627.html">EN</a>
        </h1>
      </li>
    </ul>
  </nav>
  <div class="main-content">
    <div class="paragraph">
<p><span class="image"><a class="image" href="../evttype/8.html"><img src="/images/events/jokerconf.jpg" alt="jokerconf" width="80"></a></span> <a href="../event/66.html">Joker 2017 (03.11.2017&#8201;&#8212;&#8201;04.11.2017)
</a></p>
</div>
<div class="sect3">
<h4 id="runtime_vs_compile_time_jit_vs_aot_optimizations_in_java_and_c">Runtime vs. compile time (JIT vs. AOT) optimizations in Java and C++</h4>
<div class="videoblock">
<div class="content">
<iframe width="645" height="430" src="https://www.youtube.com/embed/O87PaWkXlZ0?rel=0" frameborder="0" allowfullscreen></iframe>
</div>
</div>
<div class="paragraph event-speakers">
<p><span class="image"><a class="image" href="../speaker/126.html"><img src="/images/speakers/0126.jpg" alt="img" width="100" height="100"></a></span></p>
</div>
<div class="paragraph">
<p><em><a href="../speaker/126.html">Ionut Balosin</a></em></p>
</div>
<div class="paragraph">
<p>We&#8217;ll dwell on what really happens under the hood at compile time vs. runtime by making an analogy between C&#43;&#43; and Java.</p>
</div>
<div class="paragraph">
<p>The talk reveals how Just-in-time compiler from HotSpot/OpenJDK internally manages runtime performance optimizations for hot methods in comparison with compile time optimizations triggered on similar C&#43;&#43; source code using clang, emphasizing all of the internals and strategies used by each of them to achieve better performance.</p>
</div>
<div class="paragraph">
<p>The talk reveals how Just In Time Compiler (e.g. JIT C2) from HotSpot/OpenJDK internally manages runtime optimizations for hot methods in comparison to ahead of time approach triggered by LLVM clang on similar C&#43;&#43; source code, emphasizing all of the internals and strategies used by each Compiler to achieve better performance.</p>
</div>
<div class="paragraph">
<p>For each optimization there is a similar Java and C&#43;&#43; source code and corresponding generated assembly code in order to prove what really happens under the hood. Each test is covered by a dedicated language benchmark and conclusions.</p>
</div>
<div class="paragraph">
<p>Main agenda:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Different sequential sums (e.g. N elements array, N integers, two arrays, etc.)</p>
</li>
<li>
<p>Loop unrolling, loop peeling</p>
</li>
<li>
<p>Fields object layout</p>
</li>
<li>
<p>Null checks</p>
</li>
<li>
<p>Uncommon traps</p>
</li>
<li>
<p>Lock coarsening</p>
</li>
<li>
<p>Lock elision</p>
</li>
<li>
<p>Virtual calls</p>
</li>
<li>
<p>Scalar replacement</p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The tools used during our research study are: JITWatch, Java Measurement Harness, C&#43;&#43; Google Benchmark and perf. All test scenarios are launched against latest official Java release (e.g. 9.0.1) and a recent LLVM clang version (e.g. 5.0.0).</p>
</div>
<div class="paragraph">
<p>We aim to study what optimizations are generated by Java JIT C2 in comparison to optimizations triggered by LLVM clang on similar C&#43;&#43; source code, analyzing how powerful are ones (e.g. runtime by JIT C2) in comparison to the others (e.g. ahead of time by LLVM clang), what is the advantage and the cost of doing these optimizations at runtime (as Java does), what are the strengths and weakness of each of them. The talk might be as well interesting in the context of Java moving towards AOT, starting with 9 version. As a disclaimer, this talk is not a battle, we do not try to establish a winner between Java and C&#43;&#43;, but just to study two different Compiler approaches.</p>
</div>
<div class="ulist">
<div class="title">Ссылки:</div>
<ul>
<li>
<p><a href="https://assets.ctfassets.net/oxjq45e8ilak/4TxfHWPEJaS8yMmcIowcku/5f2434e739ee449de34ab64c5afc179b/Ionut_Balosin-Runtime-vs-compile-time_JIT-vs-AOT_optimizations-in-Java-and-C____1_.pdf" class="bare">https://assets.ctfassets.net/oxjq45e8ilak/4TxfHWPEJaS8yMmcIowcku/5f2434e739ee449de34ab64c5afc179b/Ionut_Balosin-Runtime-vs-compile-time_JIT-vs-AOT_optimizations-in-Java-and-C____1_.pdf</a></p>
</li>
</ul>
</div>
</div>
  </div>
</body>
</html>