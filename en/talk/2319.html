<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>

  <meta name="description" content="JUG Talks Finder">
  <meta name="author" content="Ivan Ponomarev">
  <link rel="stylesheet" href="/css/foundation.css">
  <link rel="stylesheet" href="/css/font-awesome.css">
  <link rel="stylesheet" href="/css/coderay.css">
  <link rel="stylesheet" href="/css/asciidoctor.css">
  <link rel="stylesheet" href="/css/custom.css">
  <!-- Yandex.Metrika counter -->
  <script type="text/javascript">
    (function (m, e, t, r, i, k, a) {
      m[i] = m[i] || function () { (m[i].a = m[i].a || []).push(arguments) };
      m[i].l = 1 * new Date(); k = e.createElement(t), a = e.getElementsByTagName(t)[0], k.async = 1, k.src = r, a.parentNode.insertBefore(k, a)
    })
      (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

    ym(64729483, "init", {
      clickmap: true,
      trackLinks: true,
      accurateTrackBounce: true
    });
  </script>
  <noscript>
    <div><img src="https://mc.yandex.ru/watch/64729483" style="position:absolute; left:-9999px;" alt="" /></div>
  </noscript>
  <!-- /Yandex.Metrika counter -->
  <script src="/js/vendor/modernizr.js"></script>
  <script src="/js/toc.js"></script>
  <script src="/js/simple-jekyll-search.min.js"></script>
</head>
<body>
  <nav class="top-bar">
    <ul class="title-area">
      <li class="name">
        <h1>
          <a href="/en/events.html">Events</a>
          <a href="/en/speakers.html">Speakers</a>
          <a href="/en/search.html">Search</a>
          <a href="/en/about.html">About</a>
          <a class="lang" href="/ru/talk/2319.html">RU</a>
        </h1>
      </li>
    </ul>
  </nav>
  <div class="main-content">
    <div class="paragraph">
<p><span class="image"><a class="image" href="../evttype/5.html"><img src="/images/events/hydra.jpg" alt="hydra" width="80"></a></span> <a href="../event/46.html">Hydra 2020 (06.07.2020&#8201;&#8212;&#8201;09.07.2020)
</a></p>
</div>
<div class="sect3">
<h4 id="erasure_coding_at_scale">Erasure Coding at Scale</h4>
<div class="paragraph event-speakers">
<p><span class="image"><a class="image" href="../speaker/1237.html"><img src="/images/speakers/1237.jpg" alt="img" width="100" height="100"></a></span></p>
</div>
<div class="paragraph">
<p><em><a href="../speaker/1237.html">Maxim Babenko</a></em></p>
</div>
<div class="paragraph">
<p>In this talk Maxim will give a brief overview of Erasure Coding schemes that we employ and discuss various real-world scenarios and lessons learned while operating these systems at scale.</p>
</div>
<div class="paragraph">
<p>&lt;p&gt;Much of Yandex Infrastructure revolves around the issues of scale and performance.&lt;/p&gt;
&lt;p&gt;Our primary storage and compute system is called YT; currently it stores over 1EB of data and utilizes about 1M of compute cores. It runs a mixture of production and ad-hoc workloads, all within a shared fleet of servers located in a number of geo-distributed datacenters.&lt;/p&gt;
&lt;p&gt;At this scale, storing and handling data efficiently becomes the matter of survival. Also with such a multitude of servers, individual hardware faults are no longer considered anomalies, rather they are regarded as ordinary events happening each day at certain predictable rates.&lt;/p&gt;
&lt;p&gt;Disk drive faults are usually handled via data replication, i.e. making physical copies of the same data piece and placing these copies on a number of machines (typically located in disjoint failure domains such as racks or even whole datacenters). The most common replication factor used nowadays is 3. RF=3 enables losing any two drives simultaneously while preserving data integrity and availability. This, however, incurs x3 overhead in disk storage space.&lt;/p&gt;
&lt;p&gt;Since 2013 we adopted a well-known technique called Erasure Coding, which helps to reduce this overhead factor to lower numbers (such as 4/3) while maintaining the same level of fault tolerance. CPU and network bandwidth consumption, however, are typically higher for Erasure Coding (compared to the usual data replication). Hence designing and scaling such a storage system requires more insights and certain care.&lt;/p&gt;
&lt;p&gt;The standard Erasure Coding approach is directly applicable to immutable data (typically called "blob chunks" in YT)</p>
</div>
<div class="paragraph">
<p>The evolution of highly scalable KV-storages (sometimes reaching many PBs in size and consuming tens of GBs of writes per second) prompted us to apply these ideas to so-called "journal chunks", i.e. append-only structures used to implement WAL journalling of RAFT-like fault-tolerant data shards.&lt;/p&gt;
&lt;p&gt;We have devised a scheme combining the notions of (read and write) quorums and Erasure Coding to reduce the disk and network bandwidth consumption thus saving on expensive NVME disks and cross-DC traffic while maintaining high throughput and low write latencies, even at higher quantiles.&lt;/p&gt;
&lt;p&gt;In this talk Maxim will give a brief overview of Erasure Coding schemes that we employ and discuss various real-world scenarios and lessons learned while operating these systems at scale.&lt;/p&gt;</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Links
:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://assets.ctfassets.net/oxjq45e8ilak/3xPcIZlk28eJfMuqmjQzLL/e94ada176f20dae5f117fe0221aa897c/Erasure_Coding_At_Scale.pdf" class="bare">https://assets.ctfassets.net/oxjq45e8ilak/3xPcIZlk28eJfMuqmjQzLL/e94ada176f20dae5f117fe0221aa897c/Erasure_Coding_At_Scale.pdf</a></p>
</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
  </div>
</body>
</html>